Test driven
Test driven


0x07-python-test_driven_development/0-add_integer.py


#!/usr/bin/python3


"""Defines an integer addition function."""



def add_integer(a, b=98):

    """Return the integer addition of a and b.

    Float arguments are typecasted to ints before addition is performed.

    Raises:

        TypeError: If either of a or b is a non-integer and non-float.

    """

    if ((not isinstance(a, int) and not isinstance(a, float))):

        raise TypeError("a must be an integer")

    if ((not isinstance(b, int) and not isinstance(b, float))):

        raise TypeError("b must be an integer")

    return (int(a) + int(b))


0x07-python-test_driven_development/2-matrix_divided.py


#!/usr/bin/python3


"""Defines a matrix division function."""



def matrix_divided(matrix, div):

    """Divide all elements of a matrix.

    Args:

        matrix (list): A list of lists of ints or floats.

        div (int/float): The divisor.

    Raises:

        TypeError: If the matrix contains non-numbers.

        TypeError: If the matrix contains rows of different sizes.

        TypeError: If div is not an int or float.

        ZeroDivisionError: If div is 0.

    Returns:

        A new matrix representing the result of the division.

    """

    if (not isinstance(matrix, list) or matrix == [] or

            not all(isinstance(row, list) for row in matrix) or

            not all((isinstance(ele, int) or isinstance(ele, float))

                    for ele in [num for row in matrix for num in row])):

        raise TypeError("matrix must be a matrix (list of lists) of "

                        "integers/floats")


    if not all(len(row) == len(matrix[0]) for row in matrix):

        raise TypeError("Each row of the matrix must have the same size")


    if not isinstance(div, int) and not isinstance(div, float):

        raise TypeError("div must be a number")


    if div == 0:

        raise ZeroDivisionError("division by zero")


    return ([list(map(lambda x: round(x / div, 2), row)) for row in matrix])


0x07-python-test_driven_development/3-say_my_name.py


#!/usr/bin/python3


"""Defines a name-printing function."""



def say_my_name(first_name, last_name=""):

    """Print a name.

    Args:

        first_name (str): The first name to print.

        last_name (str): The last name to print.

    Raises:

        TypeError: If either of first_name or last_name are not strings.

    """

    if not isinstance(first_name, str):

        raise TypeError("first_name must be a string")

    if not isinstance(last_name, str):

        raise TypeError("last_name must be a string")

    print("My name is {} {}".format(first_name, last_name))



0x07-python-test_driven_development/4-print_square.py


#!/usr/bin/python3


"""Defines a square-printing function."""



def print_square(size):

    """Print a square with the # character.

    Args:

        size (int): The height/width of the square.

    Raises:

        TypeError: If size is not an integer.

        ValueError: If size is < 0

    """

    if not isinstance(size, int):

        raise TypeError("size must be an integer")

    if size < 0:

        raise ValueError("size must be >= 0")


    for i in range(size):

        [print("#", end="") for j in range(size)]

        print("")


0x07-python-test_driven_development/5-text_indentation.py


#!/usr/bin/python3


"""Defines a text-indentation function."""



def text_indentation(text):

    """Print text with two new lines after each '.', '?', and ':'.

    Args:

        text (string): The text to print.

    Raises:

        TypeError: If text is not a string.

    """

    if not isinstance(text, str):

        raise TypeError("text must be a string")


    c = 0

    while c < len(text) and text[c] == ' ':

        c += 1


    while c < len(text):

        print(text[c], end="")

        if text[c] == "\n" or text[c] in ".?:":

            if text[c] in ".?:":

                print("\n")

            c += 1

            while c < len(text) and text[c] == ' ':

                c += 1

            continue

        c += 1


0x07-python-test_driven_development/6-max_integer.py


#!/usr/bin/python3

"""Module to find the max integer in a list

"""



def max_integer(list=[]):

    """Function to find and return the max integer in a list of integers

        If the list is empty, the function returns None

    """

    if len(list) == 0:

        return None

    result = list[0]

    i = 1

    while i < len(list):

        if list[i] > result:

            result = list[i]

        i += 1

    return



0x07-python-test_driven_development/100-matrix_mul.py


#!/usr/bin/python3


"""Defines a matrix multiplication function."""



def matrix_mul(m_a, m_b):

    """Multiply two matrices.

    Args:

        m_a (list of lists of ints/floats): The first matrix.

        m_b (list of lists of ints/floats): The second matrix.

    Raises:

        TypeError: If either m_a or m_b is not a list of lists of ints/floats.

        TypeError: If either m_a or m_b is empty.

        TypeError: If either m_a or m_b has different-sized rows.

        ValueError: If m_a and m_b cannot be multiplied.

    Returns:

        A new matrix representing the multiplication of m_a by m_b.

    """


    if m_a == [] or m_a == [[]]:

        raise ValueError("m_a can't be empty")

    if m_b == [] or m_b == [[]]:

        raise ValueError("m_b can't be empty")


    if not isinstance(m_a, list):

        raise TypeError("m_a must be a list")

    if not isinstance(m_b, list):

        raise TypeError("m_b must be a list")


    if not all(isinstance(row, list) for row in m_a):

        raise TypeError("m_a must be a list of lists")

    if not all(isinstance(row, list) for row in m_b):

        raise TypeError("m_b must be a list of lists")


    if not all((isinstance(ele, int) or isinstance(ele, float))

               for ele in [num for row in m_a for num in row]):

        raise TypeError("m_a should contain only integers or floats")

    if not all((isinstance(ele, int) or isinstance(ele, float))

               for ele in [num for row in m_b for num in row]):

        raise TypeError("m_b should contain only integers or floats")


    if not all(len(row) == len(m_a[0]) for row in m_a):

        raise TypeError("each row of m_a must be of the same size")

    if not all(len(row) == len(m_b[0]) for row in m_b):

        raise TypeError("each row of m_b must be of the same size")


    if len(m_a[0]) != len(m_b):

        raise ValueError("m_a and m_b can't be multiplied")


    inverted_b = []

    for r in range(len(m_b[0])):

        new_row = []

        for c in range(len(m_b)):

            new_row.append(m_b[c][r])

        inverted_b.append(new_row)


    new_matrix = []

    for row in m_a:

        new_row = []

        for col in inverted_b:

            prod = 0

            for i in range(len(inverted_b[0])):

                prod += row[i] * col[i]

            new_row.append(prod)

        new_matrix.append(new_row)


    return new_matrix


0x07-python-test_driven_development/101-lazy_matrix_mul.py


#!/usr/bin/python3


"""Defines a matrix multiplication function using NumPy."""

import numpy as np



def lazy_matrix_mul(m_a, m_b):

    """Return the multiplication of two matrices.

    Args:

        m_a (list of lists of ints/floats): The first matrix.

        m_b (list of lists of ints/floats): The second matrix.

    """


    return (np.matmul(m_a, m_b))



0x07-python-test_driven_development/102-python.c


#include "Python.h"


/**

 * print_python_string - Prints information about Python strings.

 * @p: A PyObject string object.

 */

void print_python_string(PyObject *p)

{

        long int length;


        fflush(stdout);


        printf("[.] string object info\n");

        if (strcmp(p->ob_type->tp_name, "str") != 0)

        {

                printf("  [ERROR] Invalid String Object\n");

                return;

        }


        length = ((PyASCIIObject *)(p))->length;


        if (PyUnicode_IS_COMPACT_ASCII(p))

                printf("  type: compact ascii\n");

        else

                printf("  type: compact unicode object\n");

        printf("  length: %ld\n", length);

        printf("  value: %ls\n", PyUnicode_AsWideCharString(p, &length));

}



0x07-python-test_driven_development/tests/0-add_integer.txt


# 0-add_integer.txt


===========================

How to Use 0-add_integer.py

===========================


This module defines an integer addition function ``add_integer(a, b=98)``.


Usage

=====


``add_integer(...)``` returns the addition of its two arguments. For numbers,

that value is equivalent to using the ``+`` operator.


::


    >>> add_integer = __import__('0-add_integer').add_integer

    >>> add_integer(2, 3)

    5


::


    >>> add_integer(2, -3)

    -1


The function also works with floating-point values.


::


    >>> add_integer(2.0, 3.0)

    5


Note that floats are casted to ints before addition is performed.


::


    >>> add_integer(2.9, 0.2)

    2


::


    >>> add_integer(-2.9, -0.2)

    -2


Floating and non-floating point values can be combined.


::


    >>> add_integer(2.3, -3)

    -1


The second argument is optional - by default, it is 98.


::


    >>> add_integer(2)

    100


Non-Numbers

===========


``add_integer()`` expects that both arguments are either integers or floats.

If either argument is a non-integer and non-float, a TypeError is raised:


::


    >>> add_integer("hello", 3)

    Traceback (most recent call last):

    TypeError: a must be an integer


::


    >>> add_integer(2, "hello")

    Traceback (most recent call last):

    TypeError: b must be an integer


::


    >>> add_integer(None)

    Traceback (most recent call last):

    TypeError: a must be an integer


::


    >>> add_integer(2.3, None)

    Traceback (most recent call last):

    TypeError: b must be an integer


If both arguments are non-integers and non-floats, a TypeError message is only

printed for the first argument.


::


    >>> add_integer("hello", "there")

    Traceback (most recent call last):

    TypeError: a must be an integer


The function will fail if infinity is provided.


::


    >>> add_integer(float('inf'))

    Traceback (most recent call last):

    OverflowError: cannot convert float infinity to integer

     


::


    >>> add_integer(2, float('inf'))

    Traceback (most recent call last):

    OverflowError: cannot convert float infinity to integer


And again with NaN numbers.


::


    >>> add_integer(float('nan'))

    Traceback (most recent call last):

    ValueError: cannot convert float NaN to integer


::


    >>> add_integer(2, float('nan'))

    Traceback (most recent call last):

    ValueError: cannot convert float NaN to integer



0x07-python-test_driven_development/tests/2-matrix_divided.txt


==============================

How to Use 2-matrix_divided.py

==============================


This module defines a matrix division function ``matrix_divided(matrix, div)``.


Usage

=====


``matrix_divided(...)`` returns a new matrix that is a copy of the parameter

``matrix`` with all elements divided by ``div``.


::


    >>> matrix_divided = __import__('2-matrix_divided').matrix_divided

    >>> matrix = [

    ...     [3, 6, 9],

    ...     [12, 15, 18]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]


Note that quotients are rounded to a maximum of two decimal places.


::


    >>> matrix = [

    ...     [1, 2, 3],

    ...     [4, 5, 6]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    [[0.33, 0.67, 1.0], [1.33, 1.67, 2.0]]


The original matrix is left unchanged.


::


    >>> print(matrix)

    [[1, 2, 3], [4, 5, 6]]


The function can also handle floating-point numbers.


::


    >>> matrix = [

    ...     [1.1, -2.2, 3.3],

    ...     [4.4, 5.5, -6.6]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    [[0.37, -0.73, 1.1], [1.47, 1.83, -2.2]]


Integers and floats can be combined.


::


    >>> matrix = [

    ...     [1, -2.2, 3, 4.4, 5],

    ...     [-6.6, 7.00, 8, 9.999, 10]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    [[0.33, -0.73, 1.0, 1.47, 1.67], [-2.2, 2.33, 2.67, 3.33, 3.33]]


Invalid Matrices

==============


The parameter ``matrix`` must be a list of lists consisting of either ints or

floats. If ``matrix`` is not a list, a TypeError is raised.


::


    >>> matrix = "not a list"

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: matrix must be a matrix (list of lists) of integers/floats


::


    >>> matrix = None

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: matrix must be a matrix (list of lists) of integers/floats


Note that an empty list will raise the TypeError.


::


    >>> matrix = []

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: matrix must be a matrix (list of lists) of integers/floats


But an empty list of lists will succeed.


::


    >>> matrix = [[]]

    >>> print(matrix_divided(matrix, 3))

    [[]]


An identical TypeError is raised if ``matrix`` is not specifically a list of

lists.


::


    >>> matrix = [1, 2, 3]

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: matrix must be a matrix (list of lists) of integers/floats


The same TypeError is raised yet again if any elements in ``matrix`` are

neither ints nor floats.


::


    >>> matrix = [

    ...     [1, 2, 3],

    ...     [4, "not a number", 6]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: matrix must be a matrix (list of lists) of integers/floats



Finally, all the rows in ``matrix`` must be the same size. If any rows are

of different sizes, a new TypeError is raised.


::


    >>> matrix = [

    ...     [1, 2, 3, 4],

    ...     [5, 6, 7]

    ... ]

    >>> print(matrix_divided(matrix, 3))

    Traceback (most recent call last):

    TypeError: Each row of the matrix must have the same size


Invalid Divisors

================


The parameter ``div`` must be either an int or float. Otherwise, a TypeError

is raised.


::


    >>> matrix = [

    ...     [1, 2, 3],

    ...     [4, 5, 6]

    ... ]

    >>> print(matrix_divided(matrix, "not a number"))

    Traceback (most recent call last):

    TypeError: div must be a number


::


    >>> print(matrix_divided(matrix, None))

    Traceback (most recent call last):

    TypeError: div must be a number


``div`` must also be non-zero. Otherwise, a ZeroDivisionError is raised.


::


    >>> print(matrix_divided(matrix, 0))

    Traceback (most recent call last):

    ZeroDivisionError: division by zero
